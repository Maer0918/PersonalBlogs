##  第四章 变量，作用域和内存问题

本章内容：

- [x] 理解基本类型和引用类型的值
- [x] 理解执行环境
- [x] 理解垃圾收集

###  基本类型和引用类型的值

对象是引用类型，其值是其对象所在内存的首地址。基本类型是值类型，其值是其内容。

**ECMAScript 中，String 是值类型，不是引用类型。**

```javascript
var str1 = "cccccccc";
var str2 = str1;
alert(str2);  //"cccccccc"
str1 = "ssssssss";
alert(str2);  //"cccccccc"
```

不过在 Python 中也是这样，String 是值类型。

```python
str1 = "cccccccc"
str2 = str1
print(str2)
str1 = "ssssssss"
print(str2)
```



*由于基本类型在一定条件下也可以转换成对象。由此推测，当基本类型调用其方法或属性时，会自动装箱。在 Java 和 C# 中都有自动装箱机制。*

Object 类型可以动态地添加或删除属性：

```javascript
var person = new Object();
person.name = "Nicholas";
alert(person.name);  //"Nicholas"
```

以上代码可以在 Chrome 浏览器按 Ctrl+Shift+I 调出的开发者工具中的 Console 里直接测试，就如同 Python 的 IDLE 一样方便。

*Object 的动态添加或删除属性与 Python 字典的动态添加删除键值对类似。*

**基本类型的值则无法添加删除属性：**

```javascript
var name = "Maer";
name.age = 21;
alert(name.age);  //undifined
```

ECMAScript 的对象是引用传递：

```javascript
var obj1 = new Object();
obj1.name = "maer";
obj2 = obj1;
alert(obj2.name);
```

ECMAScript 中所有函数参数都是按值传递，在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。*这一点和其他语言一致。*

```javascript
function setName(obj){
    obj.name = "maer";
}

var person = new Object();
setName(person);
alert(person.name);  //"maer"
```

检测基本数据类型时，使用 typeof。但检测引用类型的值时，这东西只能检测出 Object。所以当检测引用类型的值时，使用 instanceof 操作符。

###  执行环境及作用域

> 执行环境（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概念。

**执行环境的意义**：执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象（variable object）**，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

全局执行环境时最外围的一个执行环境。在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。

某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正好是这个方便的机制控制者。



当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链 前端，始终都是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象时中都是作用域链中的最后一个对象。

标识符解析是沿着作用域链一级一级地搜索标识符地过程。*如果在前面描述中，不明白作用域链地用途，看到标识符解析的时候就懂了。相对内层的执行环境可以访问相对外层的执行环境中的变量，而相对外层的执行环境则无法访问相对内层的执行环境中的变量。*搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。

*ECMAScript 和其他语言不同，在 ES 里，内部的执行环境可以访问外部执行环境中的变量，并可以修改其值。其他语言除了全局变量外，外部执行环境和内部执行环境之间是相互隔绝的，只能通过参数传递。这也就是 ES 中作用域链的作用。但是还是不太理解为什么它要这样设计，这样会增大理解代码的难度。*



*这里插叙一个小知识点，全等操作符的验证。全等操作符是对比值和类型是否都相等的，而非对比地址的。*

```javascript
var strObj = new String("string");
var strStr = "string";
alert(strObj === strStr);
alert(strObj == strStr);
```



```javascript
var color = "blue";

function changeColor(){
	if (color === "blue") {
        color = "red";
    } else {
        color = "blue";
    }
}

changeColor();

alert("Color is now " + color);
```

在这个简单的例子中，函数 changeColor() 的作用域链包含两个对象：它自己的变量对象（*也就是该函数的作用域，*其中定义着 arguments 对象）和全局环境的变量对象。可以在函数内部访问变量 color，就是因为可以在这个作用域链中找到它。

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。

####  延长作用域链

虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况会发生这种现象，当执行流进入下列任何一个语句时，作用域链就会得到加长：

* try-catch 语句的 catch 块；
* with 语句。

```javascript
function buildUrl () {
    var qs = "?debug=true";
    
    with (location) {
        var url = href + qs;
    }
    
    return url;
}
```

####  没有块级作用域

在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域（如果用 ECMAScript 的话来讲，就是它们自己的作用环境），因而支持根据条件来定义变量。但 ECMAScript 没有块级作用域，*所以块中的变量与包含其的环境处于同一个执行环境，可以相互读写。*

```javascript
if (true) {
    var color = "skyblue";
}

alert(color);    //"blue"
```

如果是在 C，C++ 或 Java 中，color 会在 if 语句执行完毕后被销毁。但在 JavaScript 中，if 语句中的声明变量会将变量添加到当前的执行环境中。在使用 for 语句时也一样。

```javascript
for (var i = 0; i < 10; i++) {
	;
}

alert(i);	//10
```

如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。

```javascript
function add(num1, num2) {
    var sum = num1 + num2;
    return sum;
}
var result = add(10, 20);
alert(sum);	//Error
```

```javascript
function add(num1, num2) {
    sum = num1 + num2;
    return sum;
}
var result = add(10, 20);
alert(sum);    //30
```

###  垃圾收集

JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。

这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码中预定的收集时间），周期性地执行这一操作。

在局部环境中，很容易判断变量是否还有存在的必要*，因为一旦退出该执行环境，则其中的所有局部变量都会被销毁*；但并非所有情况下都这么容易就能得出结论。

垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。

浏览器实现标识无用变量的策略通常有两个：

1. 标记清除（mark-and-sweep）。

   * 当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。
   * 垃圾收集器在运行时会给储存在内存中的所有变量加上“进入环境的”标记，然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而此后再被加上“离开环境的”标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除公撮，销毁那些带标记的值并回首它们所占用的内存空间。

2. 引用计数（reference counting）。引用计数的含义时跟踪记录每个值被引用的次数。

   * 引用计数中的循环引用问题，会导致计数无法降至零而导致内存泄漏。

   * ```javascript
     function problem() {
     	var obj1 = new Object();
         var obj2 = new Object();
         
         obj1.ref = obj2;
         obj2.ref = obj1;
     }
     ```

   * 以上代码的 obj1 和 obj2 在函数退出后并不会被清除，如果多次调用，则会多次泄漏内存，导致大量的内存得不到回收*，因为每次调用都会分配新的局部变量*。而标记清除策略就不会有这个问题。

####  性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。如果触发垃圾回收的阈值过低，频繁运行垃圾回收，则会导致严重的性能问题。

####  管理内存

*这里的管理内存，指的是手动管理内存的方法。*

> 使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的时防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。

为了只保存必要的数据，一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做**解除引用（dereferencing）**。这一做法适用于大多数全局便来嗯和全局对象的属性。

不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。*这里的回收时间可能时解除引用后的下个函数执行完成时，触发标记清除系统，或定时回收，或触发阈值回收。*

*这里既然说到要释放其引用，则说明存在着引用计数的垃圾回收策略。可能对于全局变量使用引用计数，对局部变量使用标记清除。*